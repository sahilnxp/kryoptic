/* automatically generated by rust-bindgen 0.66.1 */

pub const NETTLE_VERSION_MAJOR: u32 = 3;
pub const NETTLE_VERSION_MINOR: u32 = 8;
pub const NETTLE_USE_MINI_GMP: u32 = 0;
pub const MD5_DIGEST_SIZE: u32 = 16;
pub const MD5_BLOCK_SIZE: u32 = 64;
pub const MD5_DATA_SIZE: u32 = 64;
pub const _MD5_DIGEST_LENGTH: u32 = 4;
pub const SHA1_DIGEST_SIZE: u32 = 20;
pub const SHA1_BLOCK_SIZE: u32 = 64;
pub const SHA1_DATA_SIZE: u32 = 64;
pub const _SHA1_DIGEST_LENGTH: u32 = 5;
pub const SHA256_DIGEST_SIZE: u32 = 32;
pub const SHA256_BLOCK_SIZE: u32 = 64;
pub const _SHA256_DIGEST_LENGTH: u32 = 8;
pub const SHA224_DIGEST_SIZE: u32 = 28;
pub const SHA224_BLOCK_SIZE: u32 = 64;
pub const SHA512_DIGEST_SIZE: u32 = 64;
pub const SHA512_BLOCK_SIZE: u32 = 128;
pub const _SHA512_DIGEST_LENGTH: u32 = 8;
pub const SHA384_DIGEST_SIZE: u32 = 48;
pub const SHA384_BLOCK_SIZE: u32 = 128;
pub const SHA512_224_DIGEST_SIZE: u32 = 28;
pub const SHA512_224_BLOCK_SIZE: u32 = 128;
pub const SHA512_256_DIGEST_SIZE: u32 = 32;
pub const SHA512_256_BLOCK_SIZE: u32 = 128;
pub const RSA_MINIMUM_N_OCTETS: u32 = 12;
pub const RSA_MINIMUM_N_BITS: u32 = 89;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nettle_block16 {
    pub b: [u8; 16usize],
    pub w: [::std::os::raw::c_ulong; 2usize],
    pub u64_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_nettle_block16() {
    const UNINIT: ::std::mem::MaybeUninit<nettle_block16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < nettle_block16 > (), 16usize, concat!("Size of: ",
        stringify!(nettle_block16))
    );
    assert_eq!(
        ::std::mem::align_of:: < nettle_block16 > (), 8usize, concat!("Alignment of ",
        stringify!(nettle_block16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).b) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(nettle_block16), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).w) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(nettle_block16), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).u64_) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(nettle_block16), "::", stringify!(u64_))
    );
}
impl Default for nettle_block16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nettle_block8 {
    pub b: [u8; 8usize],
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_nettle_block8() {
    const UNINIT: ::std::mem::MaybeUninit<nettle_block8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < nettle_block8 > (), 8usize, concat!("Size of: ",
        stringify!(nettle_block8))
    );
    assert_eq!(
        ::std::mem::align_of:: < nettle_block8 > (), 8usize, concat!("Alignment of ",
        stringify!(nettle_block8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).b) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(nettle_block8), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).u64_) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(nettle_block8), "::", stringify!(u64_))
    );
}
impl Default for nettle_block8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nettle_random_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, length: usize, dst: *mut u8),
>;
pub type nettle_progress_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, c: ::std::os::raw::c_int),
>;
pub type nettle_realloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        p: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type nettle_set_key_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, key: *const u8),
>;
pub type nettle_cipher_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const ::std::os::raw::c_void,
        length: usize,
        dst: *mut u8,
        src: *const u8,
    ),
>;
pub type nettle_crypt_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        length: usize,
        dst: *mut u8,
        src: *const u8,
    ),
>;
pub type nettle_hash_init_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void),
>;
pub type nettle_hash_update_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, length: usize, src: *const u8),
>;
pub type nettle_hash_digest_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, length: usize, dst: *mut u8),
>;
pub type nettle_armor_length_func = ::std::option::Option<
    unsafe extern "C" fn(length: usize) -> usize,
>;
pub type nettle_armor_init_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void),
>;
pub type nettle_armor_encode_update_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        src_length: usize,
        src: *const u8,
    ) -> usize,
>;
pub type nettle_armor_encode_final_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
    ) -> usize,
>;
pub type nettle_armor_decode_update_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        dst_length: *mut usize,
        dst: *mut u8,
        src_length: usize,
        src: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type nettle_armor_decode_final_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn nettle_version_major() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_version_minor() -> ::std::os::raw::c_int;
}
pub type mp_limb_t = ::std::os::raw::c_ulong;
pub type mp_limb_signed_t = ::std::os::raw::c_long;
pub type mp_bitcnt_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct __mpz_struct {
    pub _mp_alloc: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpz_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__mpz_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < __mpz_struct > (), 16usize, concat!("Size of: ",
        stringify!(__mpz_struct))
    );
    assert_eq!(
        ::std::mem::align_of:: < __mpz_struct > (), 8usize, concat!("Alignment of ",
        stringify!(__mpz_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_alloc) as usize - ptr as usize },
        0usize, concat!("Offset of field: ", stringify!(__mpz_struct), "::",
        stringify!(_mp_alloc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_size) as usize - ptr as usize },
        4usize, concat!("Offset of field: ", stringify!(__mpz_struct), "::",
        stringify!(_mp_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_d) as usize - ptr as usize }, 8usize,
        concat!("Offset of field: ", stringify!(__mpz_struct), "::", stringify!(_mp_d))
    );
}
impl Default for __mpz_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MP_INT = __mpz_struct;
pub type mpz_t = [__mpz_struct; 1usize];
pub type mp_ptr = *mut mp_limb_t;
pub type mp_srcptr = *const mp_limb_t;
pub type mp_size_t = ::std::os::raw::c_long;
pub type mp_exp_t = ::std::os::raw::c_long;
#[repr(C)]
pub struct __mpq_struct {
    pub _mp_num: __mpz_struct,
    pub _mp_den: __mpz_struct,
}
#[test]
fn bindgen_test_layout___mpq_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__mpq_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < __mpq_struct > (), 32usize, concat!("Size of: ",
        stringify!(__mpq_struct))
    );
    assert_eq!(
        ::std::mem::align_of:: < __mpq_struct > (), 8usize, concat!("Alignment of ",
        stringify!(__mpq_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_num) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(__mpq_struct), "::", stringify!(_mp_num))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_den) as usize - ptr as usize },
        16usize, concat!("Offset of field: ", stringify!(__mpq_struct), "::",
        stringify!(_mp_den))
    );
}
impl Default for __mpq_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MP_RAT = __mpq_struct;
pub type mpq_t = [__mpq_struct; 1usize];
#[repr(C)]
pub struct __mpf_struct {
    pub _mp_prec: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_exp: mp_exp_t,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpf_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__mpf_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < __mpf_struct > (), 24usize, concat!("Size of: ",
        stringify!(__mpf_struct))
    );
    assert_eq!(
        ::std::mem::align_of:: < __mpf_struct > (), 8usize, concat!("Alignment of ",
        stringify!(__mpf_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_prec) as usize - ptr as usize },
        0usize, concat!("Offset of field: ", stringify!(__mpf_struct), "::",
        stringify!(_mp_prec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_size) as usize - ptr as usize },
        4usize, concat!("Offset of field: ", stringify!(__mpf_struct), "::",
        stringify!(_mp_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_exp) as usize - ptr as usize }, 8usize,
        concat!("Offset of field: ", stringify!(__mpf_struct), "::", stringify!(_mp_exp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr)._mp_d) as usize - ptr as usize }, 16usize,
        concat!("Offset of field: ", stringify!(__mpf_struct), "::", stringify!(_mp_d))
    );
}
impl Default for __mpf_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mpf_t = [__mpf_struct; 1usize];
pub type mpz_srcptr = *const __mpz_struct;
pub type mpz_ptr = *mut __mpz_struct;
pub type mpf_srcptr = *const __mpf_struct;
pub type mpf_ptr = *mut __mpf_struct;
pub type mpq_srcptr = *const __mpq_struct;
pub type mpq_ptr = *mut __mpq_struct;
pub const GMP_ERROR_NONE: _bindgen_ty_1 = 0;
pub const GMP_ERROR_UNSUPPORTED_ARGUMENT: _bindgen_ty_1 = 1;
pub const GMP_ERROR_DIVISION_BY_ZERO: _bindgen_ty_1 = 2;
pub const GMP_ERROR_SQRT_OF_NEGATIVE: _bindgen_ty_1 = 4;
pub const GMP_ERROR_INVALID_ARGUMENT: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn nettle_mpz_sizeinbase_256_s(x: *mut __mpz_struct) -> usize;
}
extern "C" {
    pub fn nettle_mpz_sizeinbase_256_u(x: *mut __mpz_struct) -> usize;
}
extern "C" {
    pub fn nettle_mpz_get_str_256(length: usize, s: *mut u8, x: *mut __mpz_struct);
}
extern "C" {
    pub fn nettle_mpz_set_str_256_s(x: *mut __mpz_struct, length: usize, s: *const u8);
}
extern "C" {
    pub fn nettle_mpz_init_set_str_256_s(
        x: *mut __mpz_struct,
        length: usize,
        s: *const u8,
    );
}
extern "C" {
    pub fn nettle_mpz_set_str_256_u(x: *mut __mpz_struct, length: usize, s: *const u8);
}
extern "C" {
    pub fn nettle_mpz_init_set_str_256_u(
        x: *mut __mpz_struct,
        length: usize,
        s: *const u8,
    );
}
extern "C" {
    pub fn nettle_mpz_random_size(
        x: *mut __mpz_struct,
        ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        bits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn nettle_mpz_random(
        x: *mut __mpz_struct,
        ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        n: *mut __mpz_struct,
    );
}
extern "C" {
    pub fn nettle_random_prime(
        p: *mut __mpz_struct,
        bits: ::std::os::raw::c_uint,
        top_bits_set: ::std::os::raw::c_int,
        ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        progress_ctx: *mut ::std::os::raw::c_void,
        progress: nettle_progress_func,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sexp_iterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nettle_mpz_set_sexp(
        x: *mut __mpz_struct,
        limit: ::std::os::raw::c_uint,
        i: *mut sexp_iterator,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_der_iterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nettle_asn1_der_get_bignum(
        iterator: *mut asn1_der_iterator,
        x: *mut __mpz_struct,
        max_bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_ctx {
    pub state: [u32; 4usize],
    pub count: u64,
    pub index: ::std::os::raw::c_uint,
    pub block: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_md5_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<md5_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < md5_ctx > (), 96usize, concat!("Size of: ",
        stringify!(md5_ctx))
    );
    assert_eq!(
        ::std::mem::align_of:: < md5_ctx > (), 8usize, concat!("Alignment of ",
        stringify!(md5_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).state) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(md5_ctx), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).count) as usize - ptr as usize }, 16usize,
        concat!("Offset of field: ", stringify!(md5_ctx), "::", stringify!(count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).index) as usize - ptr as usize }, 24usize,
        concat!("Offset of field: ", stringify!(md5_ctx), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).block) as usize - ptr as usize }, 28usize,
        concat!("Offset of field: ", stringify!(md5_ctx), "::", stringify!(block))
    );
}
impl Default for md5_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn nettle_md5_init(ctx: *mut md5_ctx);
}
extern "C" {
    pub fn nettle_md5_update(ctx: *mut md5_ctx, length: usize, data: *const u8);
}
extern "C" {
    pub fn nettle_md5_digest(ctx: *mut md5_ctx, length: usize, digest: *mut u8);
}
extern "C" {
    pub fn nettle_md5_compress(state: *mut u32, data: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha1_ctx {
    pub state: [u32; 5usize],
    pub count: u64,
    pub index: ::std::os::raw::c_uint,
    pub block: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sha1_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<sha1_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < sha1_ctx > (), 104usize, concat!("Size of: ",
        stringify!(sha1_ctx))
    );
    assert_eq!(
        ::std::mem::align_of:: < sha1_ctx > (), 8usize, concat!("Alignment of ",
        stringify!(sha1_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).state) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(sha1_ctx), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).count) as usize - ptr as usize }, 24usize,
        concat!("Offset of field: ", stringify!(sha1_ctx), "::", stringify!(count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).index) as usize - ptr as usize }, 32usize,
        concat!("Offset of field: ", stringify!(sha1_ctx), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).block) as usize - ptr as usize }, 36usize,
        concat!("Offset of field: ", stringify!(sha1_ctx), "::", stringify!(block))
    );
}
impl Default for sha1_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn nettle_sha1_init(ctx: *mut sha1_ctx);
}
extern "C" {
    pub fn nettle_sha1_update(ctx: *mut sha1_ctx, length: usize, data: *const u8);
}
extern "C" {
    pub fn nettle_sha1_digest(ctx: *mut sha1_ctx, length: usize, digest: *mut u8);
}
extern "C" {
    pub fn nettle_sha1_compress(state: *mut u32, data: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_ctx {
    pub state: [u32; 8usize],
    pub count: u64,
    pub index: ::std::os::raw::c_uint,
    pub block: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sha256_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<sha256_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < sha256_ctx > (), 112usize, concat!("Size of: ",
        stringify!(sha256_ctx))
    );
    assert_eq!(
        ::std::mem::align_of:: < sha256_ctx > (), 8usize, concat!("Alignment of ",
        stringify!(sha256_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).state) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(sha256_ctx), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).count) as usize - ptr as usize }, 32usize,
        concat!("Offset of field: ", stringify!(sha256_ctx), "::", stringify!(count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).index) as usize - ptr as usize }, 40usize,
        concat!("Offset of field: ", stringify!(sha256_ctx), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).block) as usize - ptr as usize }, 44usize,
        concat!("Offset of field: ", stringify!(sha256_ctx), "::", stringify!(block))
    );
}
impl Default for sha256_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn nettle_sha256_init(ctx: *mut sha256_ctx);
}
extern "C" {
    pub fn nettle_sha256_update(ctx: *mut sha256_ctx, length: usize, data: *const u8);
}
extern "C" {
    pub fn nettle_sha256_digest(ctx: *mut sha256_ctx, length: usize, digest: *mut u8);
}
extern "C" {
    pub fn nettle_sha224_init(ctx: *mut sha256_ctx);
}
extern "C" {
    pub fn nettle_sha224_digest(ctx: *mut sha256_ctx, length: usize, digest: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha512_ctx {
    pub state: [u64; 8usize],
    pub count_low: u64,
    pub count_high: u64,
    pub index: ::std::os::raw::c_uint,
    pub block: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_sha512_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<sha512_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < sha512_ctx > (), 216usize, concat!("Size of: ",
        stringify!(sha512_ctx))
    );
    assert_eq!(
        ::std::mem::align_of:: < sha512_ctx > (), 8usize, concat!("Alignment of ",
        stringify!(sha512_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).state) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(sha512_ctx), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).count_low) as usize - ptr as usize },
        64usize, concat!("Offset of field: ", stringify!(sha512_ctx), "::",
        stringify!(count_low))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).count_high) as usize - ptr as usize },
        72usize, concat!("Offset of field: ", stringify!(sha512_ctx), "::",
        stringify!(count_high))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).index) as usize - ptr as usize }, 80usize,
        concat!("Offset of field: ", stringify!(sha512_ctx), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).block) as usize - ptr as usize }, 84usize,
        concat!("Offset of field: ", stringify!(sha512_ctx), "::", stringify!(block))
    );
}
impl Default for sha512_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn nettle_sha512_init(ctx: *mut sha512_ctx);
}
extern "C" {
    pub fn nettle_sha512_update(ctx: *mut sha512_ctx, length: usize, data: *const u8);
}
extern "C" {
    pub fn nettle_sha512_digest(ctx: *mut sha512_ctx, length: usize, digest: *mut u8);
}
extern "C" {
    pub fn nettle_sha384_init(ctx: *mut sha512_ctx);
}
extern "C" {
    pub fn nettle_sha384_digest(ctx: *mut sha512_ctx, length: usize, digest: *mut u8);
}
extern "C" {
    pub fn nettle_sha512_224_init(ctx: *mut sha512_ctx);
}
extern "C" {
    pub fn nettle_sha512_224_digest(
        ctx: *mut sha512_ctx,
        length: usize,
        digest: *mut u8,
    );
}
extern "C" {
    pub fn nettle_sha512_256_init(ctx: *mut sha512_ctx);
}
extern "C" {
    pub fn nettle_sha512_256_digest(
        ctx: *mut sha512_ctx,
        length: usize,
        digest: *mut u8,
    );
}
#[repr(C)]
pub struct rsa_public_key {
    pub size: usize,
    pub n: mpz_t,
    pub e: mpz_t,
}
#[test]
fn bindgen_test_layout_rsa_public_key() {
    const UNINIT: ::std::mem::MaybeUninit<rsa_public_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < rsa_public_key > (), 40usize, concat!("Size of: ",
        stringify!(rsa_public_key))
    );
    assert_eq!(
        ::std::mem::align_of:: < rsa_public_key > (), 8usize, concat!("Alignment of ",
        stringify!(rsa_public_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).size) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(rsa_public_key), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).n) as usize - ptr as usize }, 8usize,
        concat!("Offset of field: ", stringify!(rsa_public_key), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).e) as usize - ptr as usize }, 24usize,
        concat!("Offset of field: ", stringify!(rsa_public_key), "::", stringify!(e))
    );
}
impl Default for rsa_public_key {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct rsa_private_key {
    pub size: usize,
    pub d: mpz_t,
    pub p: mpz_t,
    pub q: mpz_t,
    pub a: mpz_t,
    pub b: mpz_t,
    pub c: mpz_t,
}
#[test]
fn bindgen_test_layout_rsa_private_key() {
    const UNINIT: ::std::mem::MaybeUninit<rsa_private_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of:: < rsa_private_key > (), 104usize, concat!("Size of: ",
        stringify!(rsa_private_key))
    );
    assert_eq!(
        ::std::mem::align_of:: < rsa_private_key > (), 8usize, concat!("Alignment of ",
        stringify!(rsa_private_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).size) as usize - ptr as usize }, 0usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).d) as usize - ptr as usize }, 8usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).p) as usize - ptr as usize }, 24usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).q) as usize - ptr as usize }, 40usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).a) as usize - ptr as usize }, 56usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).b) as usize - ptr as usize }, 72usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((* ptr).c) as usize - ptr as usize }, 88usize,
        concat!("Offset of field: ", stringify!(rsa_private_key), "::", stringify!(c))
    );
}
impl Default for rsa_private_key {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn nettle_rsa_public_key_init(key: *mut rsa_public_key);
}
extern "C" {
    pub fn nettle_rsa_public_key_clear(key: *mut rsa_public_key);
}
extern "C" {
    pub fn nettle_rsa_public_key_prepare(
        key: *mut rsa_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_private_key_init(key: *mut rsa_private_key);
}
extern "C" {
    pub fn nettle_rsa_private_key_clear(key: *mut rsa_private_key);
}
extern "C" {
    pub fn nettle_rsa_private_key_prepare(
        key: *mut rsa_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pkcs1_sign(
        key: *const rsa_private_key,
        length: usize,
        digest_info: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pkcs1_sign_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        length: usize,
        digest_info: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pkcs1_verify(
        key: *const rsa_public_key,
        length: usize,
        digest_info: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_sign(
        key: *const rsa_private_key,
        hash: *mut md5_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_sign_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        hash: *mut md5_ctx,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_verify(
        key: *const rsa_public_key,
        hash: *mut md5_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_sign(
        key: *const rsa_private_key,
        hash: *mut sha1_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_sign_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        hash: *mut sha1_ctx,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_verify(
        key: *const rsa_public_key,
        hash: *mut sha1_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_sign(
        key: *const rsa_private_key,
        hash: *mut sha256_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_sign_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        hash: *mut sha256_ctx,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_verify(
        key: *const rsa_public_key,
        hash: *mut sha256_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_sign(
        key: *const rsa_private_key,
        hash: *mut sha512_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_sign_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        hash: *mut sha512_ctx,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_verify(
        key: *const rsa_public_key,
        hash: *mut sha512_ctx,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_sign_digest(
        key: *const rsa_private_key,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_md5_verify_digest(
        key: *const rsa_public_key,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_sign_digest(
        key: *const rsa_private_key,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha1_verify_digest(
        key: *const rsa_public_key,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_sign_digest(
        key: *const rsa_private_key,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha256_verify_digest(
        key: *const rsa_public_key,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_sign_digest(
        key: *const rsa_private_key,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sha512_verify_digest(
        key: *const rsa_public_key,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha256_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        salt_length: usize,
        salt: *const u8,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha256_verify_digest(
        key: *const rsa_public_key,
        salt_length: usize,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha384_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        salt_length: usize,
        salt: *const u8,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha384_verify_digest(
        key: *const rsa_public_key,
        salt_length: usize,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha512_sign_digest_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        salt_length: usize,
        salt: *const u8,
        digest: *const u8,
        s: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_pss_sha512_verify_digest(
        key: *const rsa_public_key,
        salt_length: usize,
        digest: *const u8,
        signature: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_encrypt(
        key: *const rsa_public_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        length: usize,
        cleartext: *const u8,
        cipher: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_decrypt(
        key: *const rsa_private_key,
        length: *mut usize,
        cleartext: *mut u8,
        ciphertext: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_decrypt_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        length: *mut usize,
        message: *mut u8,
        gibberish: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_sec_decrypt(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        length: usize,
        message: *mut u8,
        gibberish: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_compute_root(
        key: *const rsa_private_key,
        x: *mut __mpz_struct,
        m: *mut __mpz_struct,
    );
}
extern "C" {
    pub fn nettle_rsa_compute_root_tr(
        pub_: *const rsa_public_key,
        key: *const rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        x: *mut __mpz_struct,
        m: *mut __mpz_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_generate_keypair(
        pub_: *mut rsa_public_key,
        key: *mut rsa_private_key,
        random_ctx: *mut ::std::os::raw::c_void,
        random: nettle_random_func,
        progress_ctx: *mut ::std::os::raw::c_void,
        progress: nettle_progress_func,
        n_size: ::std::os::raw::c_uint,
        e_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nettle_buffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nettle_rsa_keypair_to_sexp(
        buffer: *mut nettle_buffer,
        algorithm_name: *const ::std::os::raw::c_char,
        pub_: *const rsa_public_key,
        priv_: *const rsa_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_keypair_from_sexp_alist(
        pub_: *mut rsa_public_key,
        priv_: *mut rsa_private_key,
        limit: ::std::os::raw::c_uint,
        i: *mut sexp_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_keypair_from_sexp(
        pub_: *mut rsa_public_key,
        priv_: *mut rsa_private_key,
        limit: ::std::os::raw::c_uint,
        length: usize,
        expr: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_public_key_from_der_iterator(
        pub_: *mut rsa_public_key,
        limit: ::std::os::raw::c_uint,
        i: *mut asn1_der_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_private_key_from_der_iterator(
        pub_: *mut rsa_public_key,
        priv_: *mut rsa_private_key,
        limit: ::std::os::raw::c_uint,
        i: *mut asn1_der_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_keypair_from_der(
        pub_: *mut rsa_public_key,
        priv_: *mut rsa_private_key,
        limit: ::std::os::raw::c_uint,
        length: usize,
        data: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nettle_rsa_keypair_to_openpgp(
        buffer: *mut nettle_buffer,
        pub_: *const rsa_public_key,
        priv_: *const rsa_private_key,
        userid: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
